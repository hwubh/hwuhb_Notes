## 问题
- 1： OPENGLES OPENGLE
- 2:  DPI
- 3: JsonUtility
- 4：使用ExecuteCommandBuffer无法及时提交渲染参数？
- 5: ClearRenderTarget 判断问题
- 6: DrawShadows twice in a pass with two different caused the mistake that both of drawers draw the same things.
- 7: Unity多光源的主光问题。
<!-- - 8：颜色空间，为什么采用这个颜色空间 -->
- 9：顶点/面/drawcall：对应CPU，GPU性能的影响，怎么影响的，对Tiled based rendering的影响，怎么影响的
- 10：其他Shadowmap，VT方案，现有方案怎么优化
- 11：切换渲染对象会带来什么消耗，为什么
- 12：Mali Complier：shader中ALU, EFU, LOAD/STORE 会带来什么消耗，哪个影响大，为什么
- 13：SRPbatcher底层原理
- 14：mono堆的内存管理；Lua的内存管理；怎么检测泄露
- 15: Lua table原理；
<!-- - 16：数据结构的实现，带优先度的queue -->
<!-- - 17：PBR urp中的写法：金属度怎么算的，粗糙度怎么算的； -->
<!-- - 18：PBR 工作流 -->
<!-- - 19：锐化原理 + fxaa -->
<!-- - 20：卷积的概念 -->
- 21：sub-pixel
- 22: TAA
- 23：ACEScc，为什么要在对数空间下调整？
<!-- - 23：hlsl怎么跨平台 -->
- 23: 间接光照，怎么烘焙，伯克利插件，法线效果，暗光；
- 24：Texture streaming，为什么在cpu
- 25：回读兼容性
- 26：皮肤效果；
- 27：折射，钻石效果
- 28：hdrp
- 29：状态机
- 30：资源策略
- 31：延迟渲染
- 32：render buffer与 texture 与 depth buffer/texture
- 33：vertex streaming splatting
- 34: VRS
- 35：Inline sampler states 怎么实现？？
## 知识点
- 1： 开启/关闭Vulkan
adb shell setprop debug.vulkan.layers "asddf"
adb shell setprop debug.vulkan.layers ""
- 2: 在资源创造材质球来控制Shade_feature 变体的生成
- 3: c# 脚本中调用 native的属性（如Object.name等）会有GC产生，多次调用需缓存。因为c++ allocate 的内存不与c#侧共用
- 4：classes that need to be destroied, Texture2D, Sprite, Material, and PlayableGraph, 
- 5: Properties of animators and material should be assign with ID instead of string since if you use string to specify it, native side will convert the string to an unique ID.    
    try to use a clss to cache all identifications.
- 6: access properties of .material will cause a new instance of material.
- 7: specify inline for methods called every frame (such as animation...)
- 8: Quality setting 等的参数设置在UI中不一定存在，需要到文本中编辑。
- 9：Load RT在有些机型上不太ok。
- 10: mesh材质虽然可以在导入时对不必要的属性进行剔除，但对于多材质，多subMesh的Mesh。即便其中一些submesh的数据结构较为简练（如只有uv1， uv2），在渲染时仍会所以submesh的最小并集进行传递。如submesh1有uv1，vertexcolor，    submesh2有uv1，uv2，那么所有的submesh都会以（uv1，uv2，vertexcolor）进行传递，因此最好将不同数据格式的submesh分在不同的mesh中使用。
- 11：mesh.uv -> UV0 -> TEXCOORD0. mesh.uv2 -> UV1 -> TEXCOORD1. mesh.uv2 -> UV3 -> TEXCOORD2 ...
- 12：UIText组件的outline顶点数较多，可以考虑使用Text Mesh Pro进行优化
- 13：深度类型的纹理在移动端不可以使用 TEXTURE2D 或 TEXTURE2D_X 进行定义，可能因为类型不符造成crash。 在定义时需要改成TEXTURE2D_FLOAT, 或者sampler2D_float. Sample 时使用 SAMPLE_TEXTURE2D.
    关闭阴影时需要仍需传入一张无用的Shadowmap，以防部分Mali机型仍然访问shadowmap访问到unity传入的Texture3D的默认纹理，发生纹理类型错误，从而发生Crash
- 14：查看vulkan报错的方式：1. 下载validation layer库，https://github.com/KhronosGroup/Vulkan-ValidationLayers/releases/tag/sdk-1.3.250.1
  1. 解压后，对应64位或者32位库放在对应位置：
    root手机：直接放在/data/local/debug/vulkan  
    非root：需要打在apk中，自己编译的引擎放在build\AndroidPlayer\Variations\il2cpp\Development\Libs\arm64-v8a或32位文件夹；
  2. 开启validation layer：
    adb shell
    setprop debug.vulkan.layers VK_LAYER_KHRONOS_validation
    setprop debug.vulkan.enable_callback 1
  3. logcat -s vulkan
  4. 运行游戏
  5. 看到Loaded layer VK_LAYER_KHRONOS_validation和Installed debug report callback表示开启成功

- 15. commandbuffer.clearRnderTarget 在setupCameraProperties -》DrawGL； 在--之后 -》 clear（color+depth+stencil）
- 16. layerMask -》 unity default layering system; renderingLayerMask -> custom layering system.
- 17. c# / c++: bool计算短接导致部分statement 未生效。
- 18: full-precision: PositionWS, UVs (for 2K or above)
- 19: Samsung/ LG: game not full screen?: if your app doesn’t specify a max_aspect ratio in the manifest, the Galaxy S8 assumes your app is unoptimized, and crunches it into a letterbox mode. https://forums.solar2d.com/t/enabling-samsung-s8-full-screen-mode/345842/2
- 20: 开启调试Vulkan： ![20230921105016](https://raw.githubusercontent.com/hwubh/hwubh_Pictures/main/20230921105016.png)
- 21: Metal Write-Only Backbuffer will disable screen capture.
- 22: Samsung设备拿内部日志： 
    1.拨号盘里可以输入*#9900#会出现一个菜单
    2.选第一个run dumpstate…
    3.完成后再选Copy to sdcard.
    4.手机里面会有个log文件夹，这里有完整的log文件
- 23： traversal performance：cache >(quicker) gameObject.transform > gameObject.GetComponent<Transform>()
- 24: Camera.main： 底层通过GameObject.FindWithTag("MainCamera")实现？
- 25：C#侧call pass by value的menber variable 时（如GameObject.tag）时会产生GC Alloc, 因为是从Native侧拷贝到C#侧的。
- 26：Transform.SetPositionAndRotation 替代调用分别Transform.SetPosition或Transform.SetRotation
- 27：Animator.SetTrigger("Attack")中的“Attack”（parameter name）会被hash成一个 parameter ID。 频繁触发时可以调用Animator.StringToHash来提前进行hash并cache,避免重复的hash运算
- 28：Material.Set...: 与Animator类似，可以通过Shader.PropertyToID来提前进行hash
- 29：Vector Math：
  - 比较距离：用SqrMagnitude来替代Magnitude可以避免一次耗时的开方运算
  - 尽量避免向量计算：3 * 2 * Vector.One >(quicker) 3 * Vector.One * 2 (算了向量两次)
- 30：Coroutine 用于定时操作，替代每帧Update中进行判断。等待一秒yield return new WaitForSeconds(1f)（WaitForSeconds(1f)也可cache）
- 31：SendMessage：底层采用了反射的实现机制，可以用事件机制来取代它
- 32: Debug.Log: release时记得排除，宏控制
- 33：用StringBuilder进行字符串的连接，替代+（GC alloc），和string.Format("one is {0}", 1)（GC，一次装箱操作(数字1被装箱成字符串"1")）
- 34: Sealed修饰: 在C#中,虚函数的调用会比直接调用开销更大,可以用sealed修饰符来修饰掉那些确保不会被继承的类或函数
- 35: 用简单的向量运算替代三角运算
- 36：shader编译：![v2-8ed526863244f5b4827c37084cb87c26_720w](https://raw.githubusercontent.com/hwubh/hwubh_Pictures/main/v2-8ed526863244f5b4827c37084cb87c26_720w.webp) ![20240617135336](https://raw.githubusercontent.com/hwubh/hwubh_Pictures/main/20240617135336.png) 在打包时，预计用到的Shader变体（DXBC/GLSL/SPIR-V）就会全都打入包中。
- 37: Blit时最好使用单个三角形而不是多个三角形组成的矩形![20240621001944](https://raw.githubusercontent.com/hwubh/hwubh_Pictures/main/20240621001944.png)
- 38: bloom显示不正常时也可以考虑下color space的设置是否有问题